=begin comment

DialMyCalls API

The DialMyCalls API

OpenAPI spec version: 2.0.1
Contact: support@dialmycalls.com
Generated by: https://github.com/swagger-api/swagger-codegen.git

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
package WWW::DialMyCalls::TextsApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::DialMyCalls::ApiClient;
use WWW::DialMyCalls::Configuration;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class   = shift;
    my (%self) = (
        'api_client' => WWW::DialMyCalls::ApiClient->instance,
        @_
    );

    #my $self = {
    #    #api_client => $options->{api_client}
    #    api_client => $default_api_client
    #}; 

    bless \%self, $class;

}


#
# cancel_text_by_id
#
# Cancel Text
# 
# @param string $text_id TextId (required)
{
    my $params = {
    'text_id' => {
        data_type => 'string',
        description => 'TextId',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cancel_text_by_id' } = { 
    	summary => 'Cancel Text',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub cancel_text_by_id {
    my ($self, %args) = @_;

    # verify the required parameter 'text_id' is set
    unless (exists $args{'text_id'}) {
      croak("Missing the required parameter 'text_id' when calling cancel_text_by_id");
    }

    # parse inputs
    my $_resource_path = '/service/text/{TextId}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # path params
    if ( exists $args{'text_id'}) {
        my $_base_variable = "{" . "TextId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'text_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# create_text
#
# Create Text
# 
# @param CreateTextParameters $create_text_parameters Request body (required)
{
    my $params = {
    'create_text_parameters' => {
        data_type => 'CreateTextParameters',
        description => 'Request body',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_text' } = { 
    	summary => 'Create Text',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub create_text {
    my ($self, %args) = @_;

    # verify the required parameter 'create_text_parameters' is set
    unless (exists $args{'create_text_parameters'}) {
      croak("Missing the required parameter 'create_text_parameters' when calling create_text");
    }

    # parse inputs
    my $_resource_path = '/service/text';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    my $_body_data;
    # body params
    if ( exists $args{'create_text_parameters'}) {
        $_body_data = $args{'create_text_parameters'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# delete_incoming_text_by_id
#
# Delete Incoming Text
# 
# @param string $text_id TextId (required)
{
    my $params = {
    'text_id' => {
        data_type => 'string',
        description => 'TextId',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_incoming_text_by_id' } = { 
    	summary => 'Delete Incoming Text',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub delete_incoming_text_by_id {
    my ($self, %args) = @_;

    # verify the required parameter 'text_id' is set
    unless (exists $args{'text_id'}) {
      croak("Missing the required parameter 'text_id' when calling delete_incoming_text_by_id");
    }

    # parse inputs
    my $_resource_path = '/incoming/text/{TextId}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # path params
    if ( exists $args{'text_id'}) {
        my $_base_variable = "{" . "TextId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'text_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# get_incoming_text_by_id
#
# Get Incoming Text
# 
# @param string $text_id TextId (required)
{
    my $params = {
    'text_id' => {
        data_type => 'string',
        description => 'TextId',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_incoming_text_by_id' } = { 
    	summary => 'Get Incoming Text',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub get_incoming_text_by_id {
    my ($self, %args) = @_;

    # verify the required parameter 'text_id' is set
    unless (exists $args{'text_id'}) {
      croak("Missing the required parameter 'text_id' when calling get_incoming_text_by_id");
    }

    # parse inputs
    my $_resource_path = '/incoming/text/{TextId}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # path params
    if ( exists $args{'text_id'}) {
        my $_base_variable = "{" . "TextId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'text_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# get_incoming_texts
#
# List Incoming Texts
# 
# @param string $range Range (ie \&quot;records&#x3D;201-300\&quot;) of texts requested (optional)
{
    my $params = {
    'range' => {
        data_type => 'string',
        description => 'Range (ie \&quot;records&#x3D;201-300\&quot;) of texts requested',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_incoming_texts' } = { 
    	summary => 'List Incoming Texts',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub get_incoming_texts {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/incoming/texts';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # header params
    if ( exists $args{'range'}) {
        $header_params->{'Range'} = $self->{api_client}->to_header_value($args{'range'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# get_short_codes
#
# List Shortcodes
# 
# @param string $range Range (ie \&quot;records&#x3D;201-300\&quot;) of shortcodes requested (optional)
{
    my $params = {
    'range' => {
        data_type => 'string',
        description => 'Range (ie \&quot;records&#x3D;201-300\&quot;) of shortcodes requested',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_short_codes' } = { 
    	summary => 'List Shortcodes',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub get_short_codes {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/shortcodes';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # header params
    if ( exists $args{'range'}) {
        $header_params->{'Range'} = $self->{api_client}->to_header_value($args{'range'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# get_text_by_id
#
# Get Text
# 
# @param string $text_id TextId (required)
{
    my $params = {
    'text_id' => {
        data_type => 'string',
        description => 'TextId',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_text_by_id' } = { 
    	summary => 'Get Text',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub get_text_by_id {
    my ($self, %args) = @_;

    # verify the required parameter 'text_id' is set
    unless (exists $args{'text_id'}) {
      croak("Missing the required parameter 'text_id' when calling get_text_by_id");
    }

    # parse inputs
    my $_resource_path = '/service/text/{TextId}';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # path params
    if ( exists $args{'text_id'}) {
        my $_base_variable = "{" . "TextId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'text_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# get_text_recipients_by_text_id
#
# Get Text Recipients
# 
# @param string $text_id TextId (required)
# @param string $range Range (ie \&quot;records&#x3D;201-300\&quot;) of recipients requested (optional)
{
    my $params = {
    'text_id' => {
        data_type => 'string',
        description => 'TextId',
        required => '1',
    },
    'range' => {
        data_type => 'string',
        description => 'Range (ie \&quot;records&#x3D;201-300\&quot;) of recipients requested',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_text_recipients_by_text_id' } = { 
    	summary => 'Get Text Recipients',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub get_text_recipients_by_text_id {
    my ($self, %args) = @_;

    # verify the required parameter 'text_id' is set
    unless (exists $args{'text_id'}) {
      croak("Missing the required parameter 'text_id' when calling get_text_recipients_by_text_id");
    }

    # parse inputs
    my $_resource_path = '/service/text/{TextId}/recipients';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # header params
    if ( exists $args{'range'}) {
        $header_params->{'Range'} = $self->{api_client}->to_header_value($args{'range'});
    }

    # path params
    if ( exists $args{'text_id'}) {
        my $_base_variable = "{" . "TextId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'text_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

#
# get_texts
#
# List Texts
# 
# @param string $range Range (ie \&quot;records&#x3D;201-300\&quot;) of texts requested (optional)
{
    my $params = {
    'range' => {
        data_type => 'string',
        description => 'Range (ie \&quot;records&#x3D;201-300\&quot;) of texts requested',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_texts' } = { 
    	summary => 'List Texts',
        params => $params,
        returns => 'object',
        };
}
# @return object
#
sub get_texts {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/service/texts';
    $_resource_path =~ s/{format}/json/; # default format to json

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json', 'application/xml');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json', 'application/xml');

    # header params
    if ( exists $args{'range'}) {
        $header_params->{'Range'} = $self->{api_client}->to_header_value($args{'range'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(api_key )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('object', $response);
    return $_response_object;
}

1;
